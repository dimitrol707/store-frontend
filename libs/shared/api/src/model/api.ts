/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * BackendStory API
 * API –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º–∏, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddToCartRequest,
  CartCreateRequest,
  CartDTO,
  CartItemDTO,
  CategoryCreateRequest,
  CategoryDTO,
  CreatePersonRequest,
  DeletePersonParams,
  EnumCreateRequest,
  EnumDTO,
  EnumValueCreateRequest,
  EnumValueDTO,
  ErrorResponse,
  GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
  LoginRequest,
  LoginResponse,
  PersonDTO,
  PkgBackendstoryCartItemCartItemCreateRequestBody,
  ProductCreateRequest,
  ProductDTO,
  ProductMediaDTO,
  PurchaseRequest,
  RegisterUserRequest,
  TokenRequest,
  TokenUserInfo,
  UploadProductMediaImageBody,
  UserDTO
} from './api.schemas';

import { customInstance } from '../config/axios';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–æ–ª–µ–π –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ä–æ–ª–∏
 */
export const getRoles = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/auth/roles`, method: 'GET', signal
    },
      options);
    }
  



export const getGetRolesQueryKey = () => {
    return [
    'auth','roles'
    ] as const;
    }

    
export const getGetRolesQueryOptions = <TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoles>>> = ({ signal }) => getRoles(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getRoles>>>
export type GetRolesQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ä–æ–ª–∏
 */

export function useGetRoles<TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
 */
export const getHeaderTokenInfo = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenUserInfo>(
      {url: `/auth/token`, method: 'GET', signal
    },
      options);
    }
  



export const getGetHeaderTokenInfoQueryKey = () => {
    return [
    'auth','token'
    ] as const;
    }

    
export const getGetHeaderTokenInfoQueryOptions = <TData = Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHeaderTokenInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHeaderTokenInfo>>> = ({ signal }) => getHeaderTokenInfo(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHeaderTokenInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getHeaderTokenInfo>>>
export type GetHeaderTokenInfoQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
 */

export function useGetHeaderTokenInfo<TData = Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHeaderTokenInfoQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–æ–∫–µ–Ω–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–æ–∫–µ–Ω–∞
 */
export const getBodyTokenInfo = (
    tokenRequest: TokenRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenUserInfo>(
      {url: `/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRequest, signal
    },
      options);
    }
  


export const getGetBodyTokenInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getBodyTokenInfo>>, TError,{data: TokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getBodyTokenInfo>>, TError,{data: TokenRequest}, TContext> => {

const mutationKey = ['getBodyTokenInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getBodyTokenInfo>>, {data: TokenRequest}> = (props) => {
          const {data} = props ?? {};

          return  getBodyTokenInfo(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetBodyTokenInfoMutationResult = NonNullable<Awaited<ReturnType<typeof getBodyTokenInfo>>>
    export type GetBodyTokenInfoMutationBody = TokenRequest
    export type GetBodyTokenInfoMutationError = ErrorResponse

    /**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–æ–∫–µ–Ω–∞
 */
export const useGetBodyTokenInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getBodyTokenInfo>>, TError,{data: TokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetBodyTokenInfoMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 */
export const getUsers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDTO[]>(
      {url: `/auth/users`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUsersQueryKey = () => {
    return [
    'auth','users'
    ] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getUser = (
    username: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDTO>(
      {url: `/auth/users/${username}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserQueryKey = (username?: string,) => {
    return [
    'auth','users',username
    ] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(username, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ä–æ–ª–µ–π –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getUserRoles = (
    username: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/auth/users/${username}/roles`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserRolesQueryKey = (username?: string,) => {
    return [
    'auth','users',username,'roles'
    ] as const;
    }

    
export const getGetUserRolesQueryOptions = <TData = Awaited<ReturnType<typeof getUserRoles>>, TError = ErrorResponse>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserRolesQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRoles>>> = ({ signal }) => getUserRoles(username, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserRoles>>>
export type GetUserRolesQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetUserRoles<TData = Awaited<ReturnType<typeof getUserRoles>>, TError = ErrorResponse>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserRolesQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const updateCartItem = (
    pkgBackendstoryCartItemCartItemCreateRequestBody: PkgBackendstoryCartItemCartItemCreateRequestBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CartItemDTO>(
      {url: `/cart-items`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: pkgBackendstoryCartItemCartItemCreateRequestBody
    },
      options);
    }
  


export const getUpdateCartItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCartItem>>, TError,{data: PkgBackendstoryCartItemCartItemCreateRequestBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCartItem>>, TError,{data: PkgBackendstoryCartItemCartItemCreateRequestBody}, TContext> => {

const mutationKey = ['updateCartItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCartItem>>, {data: PkgBackendstoryCartItemCartItemCreateRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  updateCartItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCartItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateCartItem>>>
    export type UpdateCartItemMutationBody = PkgBackendstoryCartItemCartItemCreateRequestBody
    export type UpdateCartItemMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const useUpdateCartItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCartItem>>, TError,{data: PkgBackendstoryCartItemCartItemCreateRequestBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getUpdateCartItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const createCartItem = (
    pkgBackendstoryCartItemCartItemCreateRequestBody: PkgBackendstoryCartItemCartItemCreateRequestBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO>(
      {url: `/cart-items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: pkgBackendstoryCartItemCartItemCreateRequestBody, signal
    },
      options);
    }
  


export const getCreateCartItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCartItem>>, TError,{data: PkgBackendstoryCartItemCartItemCreateRequestBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCartItem>>, TError,{data: PkgBackendstoryCartItemCartItemCreateRequestBody}, TContext> => {

const mutationKey = ['createCartItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCartItem>>, {data: PkgBackendstoryCartItemCartItemCreateRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  createCartItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCartItemMutationResult = NonNullable<Awaited<ReturnType<typeof createCartItem>>>
    export type CreateCartItemMutationBody = PkgBackendstoryCartItemCartItemCreateRequestBody
    export type CreateCartItemMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const useCreateCartItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCartItem>>, TError,{data: PkgBackendstoryCartItemCartItemCreateRequestBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateCartItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ä–∑–∏–Ω—ã –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID –∫–æ—Ä–∑–∏–Ω—ã
 */
export const getCartItemByCartId = (
    cartId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO[]>(
      {url: `/cart-items/cart/${cartId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartItemByCartIdQueryKey = (cartId?: number,) => {
    return [
    'cart-items','cart',cartId
    ] as const;
    }

    
export const getGetCartItemByCartIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartItemByCartId>>, TError = ErrorResponse>(cartId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemByCartId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartItemByCartIdQueryKey(cartId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartItemByCartId>>> = ({ signal }) => getCartItemByCartId(cartId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(cartId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartItemByCartId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartItemByCartIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartItemByCartId>>>
export type GetCartItemByCartIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID –∫–æ—Ä–∑–∏–Ω—ã
 */

export function useGetCartItemByCartId<TData = Awaited<ReturnType<typeof getCartItemByCartId>>, TError = ErrorResponse>(
 cartId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemByCartId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartItemByCartIdQueryOptions(cartId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ—Ä–∑–∏–Ω—ã –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ—Ä–∑–∏–Ω—ã
 */
export const getCartItemSearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO[]>(
      {url: `/cart-items/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getGetCartItemSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCartItemSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getCartItemSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['getCartItemSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getCartItemSearch>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  getCartItemSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetCartItemSearchMutationResult = NonNullable<Awaited<ReturnType<typeof getCartItemSearch>>>
    export type GetCartItemSearchMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type GetCartItemSearchMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ—Ä–∑–∏–Ω—ã
 */
export const useGetCartItemSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCartItemSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetCartItemSearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID
 */
export const getCartItemById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO>(
      {url: `/cart-items/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartItemByIdQueryKey = (id?: number,) => {
    return [
    'cart-items',id
    ] as const;
    }

    
export const getGetCartItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartItemById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartItemByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartItemById>>> = ({ signal }) => getCartItemById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartItemById>>>
export type GetCartItemByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID
 */

export function useGetCartItemById<TData = Awaited<ReturnType<typeof getCartItemById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartItemByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∫–æ—Ä–∑–∏–Ω—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–æ—Ä–∑–∏–Ω—É
 */
export const createCart = (
    cartCreateRequest: CartCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO>(
      {url: `/carts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cartCreateRequest, signal
    },
      options);
    }
  


export const getCreateCartMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCart>>, TError,{data: CartCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCart>>, TError,{data: CartCreateRequest}, TContext> => {

const mutationKey = ['createCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCart>>, {data: CartCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCartMutationResult = NonNullable<Awaited<ReturnType<typeof createCart>>>
    export type CreateCartMutationBody = CartCreateRequest
    export type CreateCartMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–æ—Ä–∑–∏–Ω—É
 */
export const useCreateCart = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCart>>, TError,{data: CartCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä–∑–∏–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getCartByPersonId = (
    personId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO>(
      {url: `/carts/person/${personId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartByPersonIdQueryKey = (personId?: number,) => {
    return [
    'carts','person',personId
    ] as const;
    }

    
export const getGetCartByPersonIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartByPersonId>>, TError = ErrorResponse>(personId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartByPersonId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartByPersonIdQueryKey(personId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartByPersonId>>> = ({ signal }) => getCartByPersonId(personId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(personId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartByPersonId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartByPersonIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartByPersonId>>>
export type GetCartByPersonIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetCartByPersonId<TData = Awaited<ReturnType<typeof getCartByPersonId>>, TError = ErrorResponse>(
 personId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartByPersonId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartByPersonIdQueryOptions(personId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∫–æ—Ä–∑–∏–Ω –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –∫–æ—Ä–∑–∏–Ω
 */
export const getCartSearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO[]>(
      {url: `/carts/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getGetCartSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCartSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getCartSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['getCartSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getCartSearch>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  getCartSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetCartSearchMutationResult = NonNullable<Awaited<ReturnType<typeof getCartSearch>>>
    export type GetCartSearchMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type GetCartSearchMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∫–æ—Ä–∑–∏–Ω
 */
export const useGetCartSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCartSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetCartSearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä–∑–∏–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID
 */
export const getCartById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO>(
      {url: `/carts/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartByIdQueryKey = (id?: number,) => {
    return [
    'carts',id
    ] as const;
    }

    
export const getGetCartByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartById>>> = ({ signal }) => getCartById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartById>>>
export type GetCartByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID
 */

export function useGetCartById<TData = Awaited<ReturnType<typeof getCartById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */
export const getCategoryAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO[]>(
      {url: `/categories`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryAllQueryKey = () => {
    return [
    'categories'
    ] as const;
    }

    
export const getGetCategoryAllQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryAll>>> = ({ signal }) => getCategoryAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryAllQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryAll>>>
export type GetCategoryAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */

export function useGetCategoryAll<TData = Awaited<ReturnType<typeof getCategoryAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const createCategory = (
    categoryCreateRequest: CategoryCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO>(
      {url: `/categories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: categoryCreateRequest, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: CategoryCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: CategoryCreateRequest}, TContext> => {

const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: CategoryCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = CategoryCreateRequest
    export type CreateCategoryMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const useCreateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: CategoryCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–æ–¥–∏—Ç–µ–ª—é
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—é
 */
export const getCategoryByCategoryId = (
    categoryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO[]>(
      {url: `/categories/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryByCategoryIdQueryKey = (categoryId?: number,) => {
    return [
    'categories','category',categoryId
    ] as const;
    }

    
export const getGetCategoryByCategoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError = ErrorResponse>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCategoryIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCategoryId>>> = ({ signal }) => getCategoryByCategoryId(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCategoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCategoryId>>>
export type GetCategoryByCategoryIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—é
 */

export function useGetCategoryByCategoryId<TData = Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError = ErrorResponse>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCategoryIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∫–æ–¥—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –∫–æ–¥—É
 */
export const getCategoryByCode = (
    code: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO>(
      {url: `/categories/code/${code}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryByCodeQueryKey = (code?: string,) => {
    return [
    'categories','code',code
    ] as const;
    }

    
export const getGetCategoryByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –∫–æ–¥—É
 */

export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
 */
export const getCategorySearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO[]>(
      {url: `/categories/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getGetCategorySearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCategorySearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getCategorySearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['getCategorySearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getCategorySearch>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  getCategorySearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetCategorySearchMutationResult = NonNullable<Awaited<ReturnType<typeof getCategorySearch>>>
    export type GetCategorySearchMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type GetCategorySearchMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
 */
export const useGetCategorySearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCategorySearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetCategorySearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ ID
 */
export const getCategoryById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO>(
      {url: `/categories/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryByIdQueryKey = (id?: number,) => {
    return [
    'categories',id
    ] as const;
    }

    
export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ ID
 */

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const deleteCategory = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/categories/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategory>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCategory(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategory>>>
    
    export type DeleteCategoryMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const useDeleteCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const getEnumValueAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO[]>(
      {url: `/enumeration-values`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumValueAllQueryKey = () => {
    return [
    'enumeration-values'
    ] as const;
    }

    
export const getGetEnumValueAllQueryOptions = <TData = Awaited<ReturnType<typeof getEnumValueAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumValueAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumValueAll>>> = ({ signal }) => getEnumValueAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumValueAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumValueAllQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumValueAll>>>
export type GetEnumValueAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */

export function useGetEnumValueAll<TData = Awaited<ReturnType<typeof getEnumValueAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumValueAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 * @summary –°–æ–∑–¥–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const createEnumValue = (
    enumValueCreateRequest: EnumValueCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO>(
      {url: `/enumeration-values`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enumValueCreateRequest, signal
    },
      options);
    }
  


export const getCreateEnumValueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnumValue>>, TError,{data: EnumValueCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createEnumValue>>, TError,{data: EnumValueCreateRequest}, TContext> => {

const mutationKey = ['createEnumValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEnumValue>>, {data: EnumValueCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createEnumValue(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEnumValueMutationResult = NonNullable<Awaited<ReturnType<typeof createEnumValue>>>
    export type CreateEnumValueMutationBody = EnumValueCreateRequest
    export type CreateEnumValueMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const useCreateEnumValue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnumValue>>, TError,{data: EnumValueCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateEnumValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ ID –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const getEnumValueByEnumId = (
    enumerationId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO[]>(
      {url: `/enumeration-values/enumeration/${enumerationId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumValueByEnumIdQueryKey = (enumerationId?: number,) => {
    return [
    'enumeration-values','enumeration',enumerationId
    ] as const;
    }

    
export const getGetEnumValueByEnumIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError = ErrorResponse>(enumerationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumValueByEnumIdQueryKey(enumerationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumValueByEnumId>>> = ({ signal }) => getEnumValueByEnumId(enumerationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(enumerationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumValueByEnumIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumValueByEnumId>>>
export type GetEnumValueByEnumIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ ID –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */

export function useGetEnumValueByEnumId<TData = Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError = ErrorResponse>(
 enumerationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumValueByEnumIdQueryOptions(enumerationId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const getEnumValueSearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO[]>(
      {url: `/enumeration-values/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getGetEnumValueSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getEnumValueSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getEnumValueSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['getEnumValueSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getEnumValueSearch>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  getEnumValueSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetEnumValueSearchMutationResult = NonNullable<Awaited<ReturnType<typeof getEnumValueSearch>>>
    export type GetEnumValueSearchMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type GetEnumValueSearchMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const useGetEnumValueSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getEnumValueSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetEnumValueSearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ ID
 */
export const getEnumValueById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO>(
      {url: `/enumeration-values/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumValueByIdQueryKey = (id?: number,) => {
    return [
    'enumeration-values',id
    ] as const;
    }

    
export const getGetEnumValueByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnumValueById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumValueByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumValueById>>> = ({ signal }) => getEnumValueById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumValueById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumValueByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumValueById>>>
export type GetEnumValueByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ ID
 */

export function useGetEnumValueById<TData = Awaited<ReturnType<typeof getEnumValueById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumValueByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const deleteEnumValue = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/enumeration-values/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteEnumValueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnumValue>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEnumValue>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteEnumValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEnumValue>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEnumValue(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEnumValueMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEnumValue>>>
    
    export type DeleteEnumValueMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const useDeleteEnumValue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnumValue>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteEnumValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const getEnumAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO[]>(
      {url: `/enumerations`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumAllQueryKey = () => {
    return [
    'enumerations'
    ] as const;
    }

    
export const getGetEnumAllQueryOptions = <TData = Awaited<ReturnType<typeof getEnumAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumAll>>> = ({ signal }) => getEnumAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumAllQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumAll>>>
export type GetEnumAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */

export function useGetEnumAll<TData = Awaited<ReturnType<typeof getEnumAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const createEnum = (
    enumCreateRequest: EnumCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO>(
      {url: `/enumerations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enumCreateRequest, signal
    },
      options);
    }
  


export const getCreateEnumMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnum>>, TError,{data: EnumCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createEnum>>, TError,{data: EnumCreateRequest}, TContext> => {

const mutationKey = ['createEnum'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEnum>>, {data: EnumCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createEnum(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEnumMutationResult = NonNullable<Awaited<ReturnType<typeof createEnum>>>
    export type CreateEnumMutationBody = EnumCreateRequest
    export type CreateEnumMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const useCreateEnum = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnum>>, TError,{data: EnumCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateEnumMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∫–æ–¥—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ –∫–æ–¥—É
 */
export const getEnumByCode = (
    code: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO>(
      {url: `/enumerations/code/${code}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumByCodeQueryKey = (code?: string,) => {
    return [
    'enumerations','code',code
    ] as const;
    }

    
export const getGetEnumByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getEnumByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumByCode>>> = ({ signal }) => getEnumByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumByCode>>>
export type GetEnumByCodeQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ –∫–æ–¥—É
 */

export function useGetEnumByCode<TData = Awaited<ReturnType<typeof getEnumByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const getEnumSearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO[]>(
      {url: `/enumerations/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getGetEnumSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getEnumSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getEnumSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['getEnumSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getEnumSearch>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  getEnumSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetEnumSearchMutationResult = NonNullable<Awaited<ReturnType<typeof getEnumSearch>>>
    export type GetEnumSearchMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type GetEnumSearchMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const useGetEnumSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getEnumSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetEnumSearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ ID
 */
export const getEnumById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO>(
      {url: `/enumerations/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumByIdQueryKey = (id?: number,) => {
    return [
    'enumerations',id
    ] as const;
    }

    
export const getGetEnumByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnumById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumById>>> = ({ signal }) => getEnumById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumById>>>
export type GetEnumByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ ID
 */

export function useGetEnumById<TData = Awaited<ReturnType<typeof getEnumById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const deleteEnum = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/enumerations/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteEnumMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnum>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEnum>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteEnum'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEnum>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEnum(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEnumMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEnum>>>
    
    export type DeleteEnumMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const useDeleteEnum = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnum>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteEnumMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –≤—Ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–∫–µ–Ω
 * @summary –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const loginUser = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getLoginUserMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['loginUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUser>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUserMutationResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>
    export type LoginUserMutationBody = LoginRequest
    export type LoginUserMutationError = ErrorResponse

    /**
 * @summary –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const useLoginUser = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getLoginUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω
 */
export const getPersonAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO[]>(
      {url: `/persons`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPersonAllQueryKey = () => {
    return [
    'persons'
    ] as const;
    }

    
export const getGetPersonAllQueryOptions = <TData = Awaited<ReturnType<typeof getPersonAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonAll>>> = ({ signal }) => getPersonAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPersonAllQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonAll>>>
export type GetPersonAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω
 */

export function useGetPersonAll<TData = Awaited<ReturnType<typeof getPersonAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPersonAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –ø–µ—Ä—Å–æ–Ω—É –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const createPerson = (
    createPersonRequest: CreatePersonRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO>(
      {url: `/persons`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPersonRequest, signal
    },
      options);
    }
  


export const getCreatePersonMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerson>>, TError,{data: CreatePersonRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPerson>>, TError,{data: CreatePersonRequest}, TContext> => {

const mutationKey = ['createPerson'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPerson>>, {data: CreatePersonRequest}> = (props) => {
          const {data} = props ?? {};

          return  createPerson(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePersonMutationResult = NonNullable<Awaited<ReturnType<typeof createPerson>>>
    export type CreatePersonMutationBody = CreatePersonRequest
    export type CreatePersonMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const useCreatePerson = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerson>>, TError,{data: CreatePersonRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreatePersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ª—é–¥–µ–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –ª—é–¥–µ–π
 */
export const getPersonSearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO[]>(
      {url: `/persons/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getGetPersonSearchMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPersonSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getPersonSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['getPersonSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPersonSearch>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  getPersonSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetPersonSearchMutationResult = NonNullable<Awaited<ReturnType<typeof getPersonSearch>>>
    export type GetPersonSearchMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type GetPersonSearchMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –ª—é–¥–µ–π
 */
export const useGetPersonSearch = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPersonSearch>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetPersonSearchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ª–æ–≥–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ –ª–æ–≥–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getPersonByUserLogin = (
    userLogin: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO>(
      {url: `/persons/user/${userLogin}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPersonByUserLoginQueryKey = (userLogin?: string,) => {
    return [
    'persons','user',userLogin
    ] as const;
    }

    
export const getGetPersonByUserLoginQueryOptions = <TData = Awaited<ReturnType<typeof getPersonByUserLogin>>, TError = ErrorResponse>(userLogin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonByUserLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonByUserLoginQueryKey(userLogin);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonByUserLogin>>> = ({ signal }) => getPersonByUserLogin(userLogin, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userLogin), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonByUserLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPersonByUserLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonByUserLogin>>>
export type GetPersonByUserLoginQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ –ª–æ–≥–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetPersonByUserLogin<TData = Awaited<ReturnType<typeof getPersonByUserLogin>>, TError = ErrorResponse>(
 userLogin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonByUserLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPersonByUserLoginQueryOptions(userLogin,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ ID
 */
export const getPersonById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO>(
      {url: `/persons/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPersonByIdQueryKey = (id?: number,) => {
    return [
    'persons',id
    ] as const;
    }

    
export const getGetPersonByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPersonById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonById>>> = ({ signal }) => getPersonById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPersonByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonById>>>
export type GetPersonByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ ID
 */

export function useGetPersonById<TData = Awaited<ReturnType<typeof getPersonById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPersonByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –ø–µ—Ä—Å–æ–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ (soft delete)
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const deletePerson = (
    id: number,
    params?: DeletePersonParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/persons/${id}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeletePersonMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerson>>, TError,{id: number;params?: DeletePersonParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePerson>>, TError,{id: number;params?: DeletePersonParams}, TContext> => {

const mutationKey = ['deletePerson'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePerson>>, {id: number;params?: DeletePersonParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deletePerson(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePersonMutationResult = NonNullable<Awaited<ReturnType<typeof deletePerson>>>
    
    export type DeletePersonMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const useDeletePerson = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerson>>, TError,{id: number;params?: DeletePersonParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeletePersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞. –î–ª—è –¥–æ—Å—Ç—É–ø–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è.
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
 */
export const getProductMediaByProductId = (
    productId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductMediaDTO[]>(
      {url: `/product-media/product/${productId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductMediaByProductIdQueryKey = (productId?: number,) => {
    return [
    'product-media','product',productId
    ] as const;
    }

    
export const getGetProductMediaByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductMediaByProductId>>, TError = ErrorResponse>(productId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductMediaByProductId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductMediaByProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductMediaByProductId>>> = ({ signal }) => getProductMediaByProductId(productId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductMediaByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductMediaByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductMediaByProductId>>>
export type GetProductMediaByProductIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
 */

export function useGetProductMediaByProductId<TData = Awaited<ReturnType<typeof getProductMediaByProductId>>, TError = ErrorResponse>(
 productId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductMediaByProductId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductMediaByProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: JPEG, PNG, GIF. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: 10MB.
 * @summary –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const uploadProductMediaImage = (
    uploadProductMediaImageBody: UploadProductMediaImageBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`product_id`, uploadProductMediaImageBody.product_id.toString())
formData.append(`file`, uploadProductMediaImageBody.file)

      return customInstance<ProductMediaDTO>(
      {url: `/product-media/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getUploadProductMediaImageMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadProductMediaImage>>, TError,{data: UploadProductMediaImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadProductMediaImage>>, TError,{data: UploadProductMediaImageBody}, TContext> => {

const mutationKey = ['uploadProductMediaImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadProductMediaImage>>, {data: UploadProductMediaImageBody}> = (props) => {
          const {data} = props ?? {};

          return  uploadProductMediaImage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadProductMediaImageMutationResult = NonNullable<Awaited<ReturnType<typeof uploadProductMediaImage>>>
    export type UploadProductMediaImageMutationBody = UploadProductMediaImageBody
    export type UploadProductMediaImageMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const useUploadProductMediaImage = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadProductMediaImage>>, TError,{data: UploadProductMediaImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getUploadProductMediaImageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –£–¥–∞–ª—è–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –ø–æ ID. –£–¥–∞–ª—è–µ—Ç –∫–∞–∫ –∑–∞–ø–∏—Å—å –∏–∑ –ë–î, —Ç–∞–∫ –∏ —Ñ–∞–π–ª —Å –¥–∏—Å–∫–∞.
 * @summary –£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const deleteProductMedia = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/product-media/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProductMediaMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductMedia>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProductMedia>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteProductMedia'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductMedia>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductMedia(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMediaMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductMedia>>>
    
    export type DeleteProductMediaMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const useDeleteProductMedia = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductMedia>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteProductMediaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–æ–¥—É–∫—Ç—ã
 */
export const getProductAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO[]>(
      {url: `/products`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductAllQueryKey = () => {
    return [
    'products'
    ] as const;
    }

    
export const getGetProductAllQueryOptions = <TData = Awaited<ReturnType<typeof getProductAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductAll>>> = ({ signal }) => getProductAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductAllQueryResult = NonNullable<Awaited<ReturnType<typeof getProductAll>>>
export type GetProductAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–æ–¥—É–∫—Ç—ã
 */

export function useGetProductAll<TData = Awaited<ReturnType<typeof getProductAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –ø—Ä–æ–¥—É–∫—Ç –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const createProduct = (
    productCreateRequest: ProductCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productCreateRequest, signal
    },
      options);
    }
  


export const getCreateProductMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: ProductCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: ProductCreateRequest}, TContext> => {

const mutationKey = ['createProduct'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProduct>>, {data: ProductCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createProduct(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>
    export type CreateProductMutationBody = ProductCreateRequest
    export type CreateProductMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const useCreateProduct = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: ProductCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */
export const getProductByCategoryId = (
    categoryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO[]>(
      {url: `/products/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductByCategoryIdQueryKey = (categoryId?: number,) => {
    return [
    'products','category',categoryId
    ] as const;
    }

    
export const getGetProductByCategoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductByCategoryId>>, TError = ErrorResponse>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByCategoryIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductByCategoryId>>> = ({ signal }) => getProductByCategoryId(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductByCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByCategoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductByCategoryId>>>
export type GetProductByCategoryIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */

export function useGetProductByCategoryId<TData = Awaited<ReturnType<typeof getProductByCategoryId>>, TError = ErrorResponse>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByCategoryIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∫–æ–¥—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ –∫–æ–¥—É
 */
export const getProductByCode = (
    code: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products/code/${code}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductByCodeQueryKey = (code?: string,) => {
    return [
    'products','code',code
    ] as const;
    }

    
export const getGetProductByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getProductByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductByCode>>> = ({ signal }) => getProductByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductByCode>>>
export type GetProductByCodeQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ –∫–æ–¥—É
 */

export function useGetProductByCode<TData = Awaited<ReturnType<typeof getProductByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */
export const getProductSearch = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO[]>(
      {url: `/products/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  



export const getGetProductSearchInfiniteQueryKey = (githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody?: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,) => {
    return [
    'infinite', 'products','search', githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    ] as const;
    }

export const getGetProductSearchQueryKey = (githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody?: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,) => {
    return [
    'products','search', githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    ] as const;
    }

    
export const getGetProductSearchInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProductSearch>>>, TError = ErrorResponse>(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductSearchInfiniteQueryKey(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductSearch>>> = ({ signal, pageParam }) => getProductSearch({ ...githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, offset: pageParam as number }, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductSearchInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProductSearch>>>
export type GetProductSearchInfiniteQueryError = ErrorResponse


/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */

export function useGetProductSearchInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProductSearch>>>, TError = ErrorResponse>(
 githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProductSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductSearchInfiniteQueryOptions(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetProductSearchQueryOptions = <TData = Awaited<ReturnType<typeof getProductSearch>>, TError = ErrorResponse>(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductSearchQueryKey(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductSearch>>> = ({ signal }) => getProductSearch(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getProductSearch>>>
export type GetProductSearchQueryError = ErrorResponse


/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */

export function useGetProductSearch<TData = Awaited<ReturnType<typeof getProductSearch>>, TError = ErrorResponse>(
 githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductSearchQueryOptions(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID
 */
export const getProductById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductByIdQueryKey = (id?: number,) => {
    return [
    'products',id
    ] as const;
    }

    
export const getGetProductByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductById>>> = ({ signal }) => getProductById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductById>>>
export type GetProductByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID
 */

export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const deleteProduct = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/products/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProductMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteProduct'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProduct>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProduct(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>
    
    export type DeleteProductMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const useDeleteProduct = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –û—Ñ–æ—Ä–º–ª—è–µ—Ç –ø–æ–∫—É–ø–∫—É –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–π –∫–æ—Ä–∑–∏–Ω–µ
 * @summary –û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–∫—É–ø–∫—É –∫–æ—Ä–∑–∏–Ω—ã
 */
export const purchaseCart = (
    purchaseRequest: PurchaseRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/purchases`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: purchaseRequest, signal
    },
      options);
    }
  


export const getPurchaseCartMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchaseCart>>, TError,{data: PurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchaseCart>>, TError,{data: PurchaseRequest}, TContext> => {

const mutationKey = ['purchaseCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchaseCart>>, {data: PurchaseRequest}> = (props) => {
          const {data} = props ?? {};

          return  purchaseCart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchaseCartMutationResult = NonNullable<Awaited<ReturnType<typeof purchaseCart>>>
    export type PurchaseCartMutationBody = PurchaseRequest
    export type PurchaseCartMutationError = ErrorResponse

    /**
 * @summary –û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–∫—É–ø–∫—É –∫–æ—Ä–∑–∏–Ω—ã
 */
export const usePurchaseCart = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchaseCart>>, TError,{data: PurchaseRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getPurchaseCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –î–æ–±–∞–≤–ª—è–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä –≤ –∫–æ—Ä–∑–∏–Ω—É
 */
export const addToCart = (
    addToCartRequest: AddToCartRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/purchases/cart`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addToCartRequest, signal
    },
      options);
    }
  


export const getAddToCartMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext> => {

const mutationKey = ['addToCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToCart>>, {data: AddToCartRequest}> = (props) => {
          const {data} = props ?? {};

          return  addToCart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddToCartMutationResult = NonNullable<Awaited<ReturnType<typeof addToCart>>>
    export type AddToCartMutationBody = AddToCartRequest
    export type AddToCartMutationError = ErrorResponse

    /**
 * @summary –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä –≤ –∫–æ—Ä–∑–∏–Ω—É
 */
export const useAddToCart = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getAddToCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–∫–µ–Ω
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const registerUser = (
    registerUserRequest: RegisterUserRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerUserRequest, signal
    },
      options);
    }
  


export const getRegisterUserMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegisterUserRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegisterUserRequest}, TContext> => {

const mutationKey = ['registerUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUser>>, {data: RegisterUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUserMutationResult = NonNullable<Awaited<ReturnType<typeof registerUser>>>
    export type RegisterUserMutationBody = RegisterUserRequest
    export type RegisterUserMutationError = ErrorResponse

    /**
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const useRegisterUser = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegisterUserRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getRegisterUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
