/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * BackendStory API
 * API –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º–∏, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CartCreateRequest,
  CartDTO,
  CartItemDTO,
  CartItemUpdateRequest,
  CategoryCreateRequest,
  CategoryDTO,
  CreatePersonRequest,
  DeletePersonParams,
  DeleteProductParams,
  EnumCreateRequest,
  EnumDTO,
  EnumValueDTO,
  ErrorResponse,
  GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
  LoginRequest,
  LoginResponse,
  OrderCreateRequest,
  OrderDTO,
  OrderItemCreateRequest,
  OrderItemDTO,
  PersonDTO,
  ProductCreateRequest,
  ProductDTO,
  ProductMediaDTO,
  ProductPriceChangeRequest,
  ProductStatusChangeRequest,
  RegisterUserRequest,
  TokenRequest,
  TokenUserInfo,
  UploadProductMediaImageBody,
  UserDTO,
  ValidationErrorResponse
} from './api.schemas';

import { customInstance } from '../config/axios';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–æ–ª–µ–π –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ä–æ–ª–∏
 */
export const getRoles = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/auth/roles`, method: 'GET', signal
    },
      options);
    }
  



export const getGetRolesQueryKey = () => {
    return [
    'auth','roles'
    ] as const;
    }

    
export const getGetRolesQueryOptions = <TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoles>>> = ({ signal }) => getRoles(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getRoles>>>
export type GetRolesQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ä–æ–ª–∏
 */

export function useGetRoles<TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
 */
export const getHeaderTokenInfo = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenUserInfo>(
      {url: `/auth/token`, method: 'GET', signal
    },
      options);
    }
  



export const getGetHeaderTokenInfoQueryKey = () => {
    return [
    'auth','token'
    ] as const;
    }

    
export const getGetHeaderTokenInfoQueryOptions = <TData = Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHeaderTokenInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHeaderTokenInfo>>> = ({ signal }) => getHeaderTokenInfo(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHeaderTokenInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getHeaderTokenInfo>>>
export type GetHeaderTokenInfoQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
 */

export function useGetHeaderTokenInfo<TData = Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHeaderTokenInfo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHeaderTokenInfoQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–æ–∫–µ–Ω–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–æ–∫–µ–Ω–∞
 */
export const getBodyTokenInfo = (
    tokenRequest: TokenRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenUserInfo>(
      {url: `/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRequest, signal
    },
      options);
    }
  


export const getGetBodyTokenInfoMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getBodyTokenInfo>>, TError,{data: TokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getBodyTokenInfo>>, TError,{data: TokenRequest}, TContext> => {

const mutationKey = ['getBodyTokenInfo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getBodyTokenInfo>>, {data: TokenRequest}> = (props) => {
          const {data} = props ?? {};

          return  getBodyTokenInfo(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetBodyTokenInfoMutationResult = NonNullable<Awaited<ReturnType<typeof getBodyTokenInfo>>>
    export type GetBodyTokenInfoMutationBody = TokenRequest
    export type GetBodyTokenInfoMutationError = ErrorResponse

    /**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ç–æ–∫–µ–Ω–∞
 */
export const useGetBodyTokenInfo = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getBodyTokenInfo>>, TError,{data: TokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getGetBodyTokenInfoMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 */
export const getUsers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDTO[]>(
      {url: `/auth/users`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUsersQueryKey = () => {
    return [
    'auth','users'
    ] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getUser = (
    username: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDTO>(
      {url: `/auth/users/${username}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserQueryKey = (username?: string,) => {
    return [
    'auth','users',username
    ] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(username, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorResponse>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ä–æ–ª–µ–π –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getUserRoles = (
    username: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/auth/users/${username}/roles`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserRolesQueryKey = (username?: string,) => {
    return [
    'auth','users',username,'roles'
    ] as const;
    }

    
export const getGetUserRolesQueryOptions = <TData = Awaited<ReturnType<typeof getUserRoles>>, TError = ErrorResponse>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserRolesQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRoles>>> = ({ signal }) => getUserRoles(username, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserRoles>>>
export type GetUserRolesQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetUserRoles<TData = Awaited<ReturnType<typeof getUserRoles>>, TError = ErrorResponse>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserRolesQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const createCartItem = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/cart-items`, method: 'DELETE'
    },
      options);
    }
  


export const getCreateCartItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCartItem>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCartItem>>, TError,void, TContext> => {

const mutationKey = ['createCartItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCartItem>>, void> = () => {
          

          return  createCartItem(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCartItemMutationResult = NonNullable<Awaited<ReturnType<typeof createCartItem>>>
    
    export type CreateCartItemMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const useCreateCartItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCartItem>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateCartItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –û–±–Ω–æ–≤–ª—è–µ—Ç —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –û–±–Ω–æ–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const updateCartItem = (
    cartItemUpdateRequest: CartItemUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CartItemDTO>(
      {url: `/cart-items`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: cartItemUpdateRequest
    },
      options);
    }
  


export const getUpdateCartItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCartItem>>, TError,{data: CartItemUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCartItem>>, TError,{data: CartItemUpdateRequest}, TContext> => {

const mutationKey = ['updateCartItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCartItem>>, {data: CartItemUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateCartItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCartItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateCartItem>>>
    export type UpdateCartItemMutationBody = CartItemUpdateRequest
    export type UpdateCartItemMutationError = ErrorResponse

    /**
 * @summary –û–±–Ω–æ–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export const useUpdateCartItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCartItem>>, TError,{data: CartItemUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getUpdateCartItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ä–∑–∏–Ω—ã –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID –∫–æ—Ä–∑–∏–Ω—ã
 */
export const getCartItemByCartId = (
    cartId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO[]>(
      {url: `/cart-items/cart/${cartId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartItemByCartIdQueryKey = (cartId?: number,) => {
    return [
    'cart-items','cart',cartId
    ] as const;
    }

    
export const getGetCartItemByCartIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartItemByCartId>>, TError = ErrorResponse>(cartId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemByCartId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartItemByCartIdQueryKey(cartId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartItemByCartId>>> = ({ signal }) => getCartItemByCartId(cartId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(cartId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartItemByCartId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartItemByCartIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartItemByCartId>>>
export type GetCartItemByCartIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID –∫–æ—Ä–∑–∏–Ω—ã
 */

export function useGetCartItemByCartId<TData = Awaited<ReturnType<typeof getCartItemByCartId>>, TError = ErrorResponse>(
 cartId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemByCartId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartItemByCartIdQueryOptions(cartId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ—Ä–∑–∏–Ω—ã –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ—Ä–∑–∏–Ω—ã
 */
export const searchCartItem = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO[]>(
      {url: `/cart-items/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchCartItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCartItem>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchCartItem>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchCartItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchCartItem>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchCartItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchCartItemMutationResult = NonNullable<Awaited<ReturnType<typeof searchCartItem>>>
    export type SearchCartItemMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchCartItemMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ—Ä–∑–∏–Ω—ã
 */
export const useSearchCartItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCartItem>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchCartItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID
 */
export const getCartItemById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartItemDTO>(
      {url: `/cart-items/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartItemByIdQueryKey = (id?: number,) => {
    return [
    'cart-items',id
    ] as const;
    }

    
export const getGetCartItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartItemById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartItemByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartItemById>>> = ({ signal }) => getCartItemById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartItemById>>>
export type GetCartItemByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä–∑–∏–Ω—ã –ø–æ ID
 */

export function useGetCartItemById<TData = Awaited<ReturnType<typeof getCartItemById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartItemById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartItemByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∫–æ—Ä–∑–∏–Ω—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–æ—Ä–∑–∏–Ω—É
 */
export const createCart = (
    cartCreateRequest: CartCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO>(
      {url: `/carts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: cartCreateRequest, signal
    },
      options);
    }
  


export const getCreateCartMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCart>>, TError,{data: CartCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCart>>, TError,{data: CartCreateRequest}, TContext> => {

const mutationKey = ['createCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCart>>, {data: CartCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCartMutationResult = NonNullable<Awaited<ReturnType<typeof createCart>>>
    export type CreateCartMutationBody = CartCreateRequest
    export type CreateCartMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–æ—Ä–∑–∏–Ω—É
 */
export const useCreateCart = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCart>>, TError,{data: CartCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä–∑–∏–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getCartByPersonId = (
    personId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO>(
      {url: `/carts/person/${personId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartByPersonIdQueryKey = (personId?: number,) => {
    return [
    'carts','person',personId
    ] as const;
    }

    
export const getGetCartByPersonIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartByPersonId>>, TError = ErrorResponse>(personId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartByPersonId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartByPersonIdQueryKey(personId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartByPersonId>>> = ({ signal }) => getCartByPersonId(personId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(personId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartByPersonId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartByPersonIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartByPersonId>>>
export type GetCartByPersonIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetCartByPersonId<TData = Awaited<ReturnType<typeof getCartByPersonId>>, TError = ErrorResponse>(
 personId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartByPersonId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartByPersonIdQueryOptions(personId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∫–æ—Ä–∑–∏–Ω –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –∫–æ—Ä–∑–∏–Ω
 */
export const searchCart = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO[]>(
      {url: `/carts/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchCartMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCart>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchCart>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchCart>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchCart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchCartMutationResult = NonNullable<Awaited<ReturnType<typeof searchCart>>>
    export type SearchCartMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchCartMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∫–æ—Ä–∑–∏–Ω
 */
export const useSearchCart = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCart>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä–∑–∏–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID
 */
export const getCartById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CartDTO>(
      {url: `/carts/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCartByIdQueryKey = (id?: number,) => {
    return [
    'carts',id
    ] as const;
    }

    
export const getGetCartByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCartById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCartById>>> = ({ signal }) => getCartById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCartById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCartById>>>
export type GetCartByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É –ø–æ ID
 */

export function useGetCartById<TData = Awaited<ReturnType<typeof getCartById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCartById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */
export const getCategoryAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO[]>(
      {url: `/categories`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryAllQueryKey = () => {
    return [
    'categories'
    ] as const;
    }

    
export const getGetCategoryAllQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryAll>>> = ({ signal }) => getCategoryAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryAllQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryAll>>>
export type GetCategoryAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */

export function useGetCategoryAll<TData = Awaited<ReturnType<typeof getCategoryAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const createCategory = (
    categoryCreateRequest: CategoryCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO>(
      {url: `/categories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: categoryCreateRequest, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: CategoryCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: CategoryCreateRequest}, TContext> => {

const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: CategoryCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = CategoryCreateRequest
    export type CreateCategoryMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const useCreateCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: CategoryCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É —Ä–æ–¥–∏—Ç–µ–ª—é
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—é
 */
export const getCategoryByCategoryId = (
    categoryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO[]>(
      {url: `/categories/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryByCategoryIdQueryKey = (categoryId?: number,) => {
    return [
    'categories','category',categoryId
    ] as const;
    }

    
export const getGetCategoryByCategoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError = ErrorResponse>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCategoryIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCategoryId>>> = ({ signal }) => getCategoryByCategoryId(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCategoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCategoryId>>>
export type GetCategoryByCategoryIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—é
 */

export function useGetCategoryByCategoryId<TData = Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError = ErrorResponse>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCategoryIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∫–æ–¥—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –∫–æ–¥—É
 */
export const getCategoryByCode = (
    code: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO>(
      {url: `/categories/code/${code}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryByCodeQueryKey = (code?: string,) => {
    return [
    'categories','code',code
    ] as const;
    }

    
export const getGetCategoryByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryByCode>>> = ({ signal }) => getCategoryByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryByCode>>>
export type GetCategoryByCodeQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –∫–æ–¥—É
 */

export function useGetCategoryByCode<TData = Awaited<ReturnType<typeof getCategoryByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
 */
export const searchCategory = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO[]>(
      {url: `/categories/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCategory>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchCategory>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchCategory>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof searchCategory>>>
    export type SearchCategoryMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchCategoryMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
 */
export const useSearchCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCategory>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ ID
 */
export const getCategoryById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CategoryDTO>(
      {url: `/categories/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCategoryByIdQueryKey = (id?: number,) => {
    return [
    'categories',id
    ] as const;
    }

    
export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ ID
 */

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const deleteCategory = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/categories/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCategoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategory>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCategory(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategory>>>
    
    export type DeleteCategoryMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é
 */
export const useDeleteCategory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteCategoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const getEnumValueAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO[]>(
      {url: `/enumeration-values`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumValueAllQueryKey = () => {
    return [
    'enumeration-values'
    ] as const;
    }

    
export const getGetEnumValueAllQueryOptions = <TData = Awaited<ReturnType<typeof getEnumValueAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumValueAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumValueAll>>> = ({ signal }) => getEnumValueAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumValueAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumValueAllQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumValueAll>>>
export type GetEnumValueAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */

export function useGetEnumValueAll<TData = Awaited<ReturnType<typeof getEnumValueAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumValueAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const createEnumValue = (
    enumCreateRequest: EnumCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO>(
      {url: `/enumerations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enumCreateRequest, signal
    },
      options);
    }
  


export const getCreateEnumValueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnumValue>>, TError,{data: EnumCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createEnumValue>>, TError,{data: EnumCreateRequest}, TContext> => {

const mutationKey = ['createEnumValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEnumValue>>, {data: EnumCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createEnumValue(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEnumValueMutationResult = NonNullable<Awaited<ReturnType<typeof createEnumValue>>>
    export type CreateEnumValueMutationBody = EnumCreateRequest
    export type CreateEnumValueMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const useCreateEnumValue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnumValue>>, TError,{data: EnumCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateEnumValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ ID –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const getEnumValueByEnumId = (
    enumerationId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO[]>(
      {url: `/enumeration-values/enumeration/${enumerationId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumValueByEnumIdQueryKey = (enumerationId?: number,) => {
    return [
    'enumeration-values','enumeration',enumerationId
    ] as const;
    }

    
export const getGetEnumValueByEnumIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError = ErrorResponse>(enumerationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumValueByEnumIdQueryKey(enumerationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumValueByEnumId>>> = ({ signal }) => getEnumValueByEnumId(enumerationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(enumerationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumValueByEnumIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumValueByEnumId>>>
export type GetEnumValueByEnumIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ ID –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */

export function useGetEnumValueByEnumId<TData = Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError = ErrorResponse>(
 enumerationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueByEnumId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumValueByEnumIdQueryOptions(enumerationId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const searchEnumValue = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO[]>(
      {url: `/enumeration-values/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchEnumValueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchEnumValue>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchEnumValue>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchEnumValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchEnumValue>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchEnumValue(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchEnumValueMutationResult = NonNullable<Awaited<ReturnType<typeof searchEnumValue>>>
    export type SearchEnumValueMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchEnumValueMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const useSearchEnumValue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchEnumValue>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchEnumValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ ID
 */
export const getEnumValueById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumValueDTO>(
      {url: `/enumeration-values/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumValueByIdQueryKey = (id?: number,) => {
    return [
    'enumeration-values',id
    ] as const;
    }

    
export const getGetEnumValueByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnumValueById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumValueByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumValueById>>> = ({ signal }) => getEnumValueById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumValueById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumValueByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumValueById>>>
export type GetEnumValueByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ ID
 */

export function useGetEnumValueById<TData = Awaited<ReturnType<typeof getEnumValueById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumValueById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumValueByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const deleteEnumValue = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/enumeration-values/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteEnumValueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnumValue>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEnumValue>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteEnumValue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEnumValue>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEnumValue(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEnumValueMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEnumValue>>>
    
    export type DeleteEnumValueMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const useDeleteEnumValue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnumValue>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteEnumValueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */
export const getEnumAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO[]>(
      {url: `/enumerations`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumAllQueryKey = () => {
    return [
    'enumerations'
    ] as const;
    }

    
export const getGetEnumAllQueryOptions = <TData = Awaited<ReturnType<typeof getEnumAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumAll>>> = ({ signal }) => getEnumAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumAllQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumAll>>>
export type GetEnumAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è
 */

export function useGetEnumAll<TData = Awaited<ReturnType<typeof getEnumAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∫–æ–¥—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ –∫–æ–¥—É
 */
export const getEnumByCode = (
    code: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO>(
      {url: `/enumerations/code/${code}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumByCodeQueryKey = (code?: string,) => {
    return [
    'enumerations','code',code
    ] as const;
    }

    
export const getGetEnumByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getEnumByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumByCode>>> = ({ signal }) => getEnumByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumByCode>>>
export type GetEnumByCodeQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ –∫–æ–¥—É
 */

export function useGetEnumByCode<TData = Awaited<ReturnType<typeof getEnumByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const searchEnum = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO[]>(
      {url: `/enumerations/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchEnumMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchEnum>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchEnum>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchEnum'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchEnum>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchEnum(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchEnumMutationResult = NonNullable<Awaited<ReturnType<typeof searchEnum>>>
    export type SearchEnumMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchEnumMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π
 */
export const useSearchEnum = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchEnum>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchEnumMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ ID
 */
export const getEnumById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EnumDTO>(
      {url: `/enumerations/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEnumByIdQueryKey = (id?: number,) => {
    return [
    'enumerations',id
    ] as const;
    }

    
export const getGetEnumByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnumById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnumByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnumById>>> = ({ signal }) => getEnumById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnumById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnumByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnumById>>>
export type GetEnumByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ ID
 */

export function useGetEnumById<TData = Awaited<ReturnType<typeof getEnumById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnumById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnumByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const deleteEnum = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/enumerations/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteEnumMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnum>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEnum>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteEnum'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEnum>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEnum(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEnumMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEnum>>>
    
    export type DeleteEnumMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
 */
export const useDeleteEnum = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnum>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteEnumMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –≤—Ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–∫–µ–Ω
 * @summary –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const loginUser = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getLoginUserMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['loginUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUser>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUserMutationResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>
    export type LoginUserMutationBody = LoginRequest
    export type LoginUserMutationError = ErrorResponse

    /**
 * @summary –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const useLoginUser = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getLoginUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞, —Å–≤—è–∑—ã–≤–∞—è —Ç–æ–≤–∞—Ä –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã —Å –∑–∞–∫–∞–∑–æ–º
 * @summary –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞
 */
export const createOrderItem = (
    orderItemCreateRequest: OrderItemCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderItemDTO>(
      {url: `/order-items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderItemCreateRequest, signal
    },
      options);
    }
  


export const getCreateOrderItemMutationOptions = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrderItem>>, TError,{data: OrderItemCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createOrderItem>>, TError,{data: OrderItemCreateRequest}, TContext> => {

const mutationKey = ['createOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrderItem>>, {data: OrderItemCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOrderItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof createOrderItem>>>
    export type CreateOrderItemMutationBody = OrderItemCreateRequest
    export type CreateOrderItemMutationError = ErrorResponse | ValidationErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞
 */
export const useCreateOrderItem = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrderItem>>, TError,{data: OrderItemCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateOrderItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞–∫–∞–∑–∞ –ø–æ ID –∑–∞–∫–∞–∑–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∑–∞–∫–∞–∑–∞
 */
export const getOrderItemsByOrderId = (
    orderId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderItemDTO[]>(
      {url: `/order-items/order/${orderId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrderItemsByOrderIdQueryKey = (orderId?: number,) => {
    return [
    'order-items','order',orderId
    ] as const;
    }

    
export const getGetOrderItemsByOrderIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderItemsByOrderId>>, TError = ErrorResponse>(orderId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItemsByOrderId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemsByOrderIdQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItemsByOrderId>>> = ({ signal }) => getOrderItemsByOrderId(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderItemsByOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemsByOrderIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItemsByOrderId>>>
export type GetOrderItemsByOrderIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∑–∞–∫–∞–∑–∞
 */

export function useGetOrderItemsByOrderId<TData = Awaited<ReturnType<typeof getOrderItemsByOrderId>>, TError = ErrorResponse>(
 orderId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItemsByOrderId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemsByOrderIdQueryOptions(orderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞–∫–∞–∑–∞ –ø–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º –ø–æ–∏—Å–∫–∞ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
 * @summary –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞–∫–∞–∑–∞
 */
export const searchOrderItems = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderItemDTO[]>(
      {url: `/order-items/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchOrderItemsMutationOptions = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchOrderItems>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchOrderItems>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchOrderItems'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchOrderItems>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchOrderItems(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchOrderItemsMutationResult = NonNullable<Awaited<ReturnType<typeof searchOrderItems>>>
    export type SearchOrderItemsMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchOrderItemsMutationError = ErrorResponse | ValidationErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞–∫–∞–∑–∞
 */
export const useSearchOrderItems = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchOrderItems>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchOrderItemsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞ –ø–æ ID
 */
export const getOrderItemById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderItemDTO>(
      {url: `/order-items/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrderItemByIdQueryKey = (id?: number,) => {
    return [
    'order-items',id
    ] as const;
    }

    
export const getGetOrderItemByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderItemById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItemById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderItemByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderItemById>>> = ({ signal }) => getOrderItemById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderItemById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderItemByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderItemById>>>
export type GetOrderItemByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞ –ø–æ ID
 */

export function useGetOrderItemById<TData = Awaited<ReturnType<typeof getOrderItemById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderItemById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderItemByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞ –ø–æ ID (—Ç–æ–ª—å–∫–æ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–∞—Ö)
 * @summary –£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞
 */
export const deleteOrderItem = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/order-items/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteOrderItemMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteOrderItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOrderItem>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteOrderItem(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOrderItemMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOrderItem>>>
    
    export type DeleteOrderItemMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞–∫–∞–∑–∞
 */
export const useDeleteOrderItem = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrderItem>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteOrderItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –ò–∑–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ç—É—Å —ç–ª–µ–º–µ–Ω—Ç–∞ –∑–∞–∫–∞–∑–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≥–æ—Ç–æ–≤ –∫ –æ—Ç–≥—Ä—É–∑–∫–µ, –æ—Ç–≥—Ä—É–∂–µ–Ω –∏ —Ç.–¥.)
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å —ç–ª–µ–º–µ–Ω—Ç–∞ –∑–∞–∫–∞–∑–∞
 */
export const changeOrderItemStatus = (
    id: number,
    status: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderItemDTO>(
      {url: `/order-items/${id}/change-status/${status}`, method: 'POST', signal
    },
      options);
    }
  


export const getChangeOrderItemStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeOrderItemStatus>>, TError,{id: number;status: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changeOrderItemStatus>>, TError,{id: number;status: string}, TContext> => {

const mutationKey = ['changeOrderItemStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeOrderItemStatus>>, {id: number;status: string}> = (props) => {
          const {id,status} = props ?? {};

          return  changeOrderItemStatus(id,status,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeOrderItemStatusMutationResult = NonNullable<Awaited<ReturnType<typeof changeOrderItemStatus>>>
    
    export type ChangeOrderItemStatusMutationError = ErrorResponse

    /**
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å —ç–ª–µ–º–µ–Ω—Ç–∞ –∑–∞–∫–∞–∑–∞
 */
export const useChangeOrderItemStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeOrderItemStatus>>, TError,{id: number;status: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getChangeOrderItemStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã
 * @summary –°–æ–∑–¥–∞—Ç—å –∑–∞–∫–∞–∑
 */
export const createOrder = (
    orderCreateRequest: OrderCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO>(
      {url: `/orders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderCreateRequest, signal
    },
      options);
    }
  


export const getCreateOrderMutationOptions = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: OrderCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: OrderCreateRequest}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: OrderCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = OrderCreateRequest
    export type CreateOrderMutationError = ErrorResponse | ValidationErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –∑–∞–∫–∞–∑
 */
export const useCreateOrder = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: OrderCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –î–æ–±–∞–≤–ª—è–µ—Ç –¥–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞ –∏ –Ω–∞–∑–Ω–∞—á–∞–µ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 * @summary –î–æ–±–∞–≤–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞
 */
export const addDetails = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO>(
      {url: `/orders/add-details`, method: 'POST', signal
    },
      options);
    }
  


export const getAddDetailsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addDetails>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addDetails>>, TError,void, TContext> => {

const mutationKey = ['addDetails'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addDetails>>, void> = () => {
          

          return  addDetails(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddDetailsMutationResult = NonNullable<Awaited<ReturnType<typeof addDetails>>>
    
    export type AddDetailsMutationError = ErrorResponse

    /**
 * @summary –î–æ–±–∞–≤–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞
 */
export const useAddDetails = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addDetails>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getAddDetailsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤ –ø–æ ID –∫–ª–∏–µ–Ω—Ç–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –∫–ª–∏–µ–Ω—Ç–∞
 */
export const getOrdersByClientId = (
    clientId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO[]>(
      {url: `/orders/client/${clientId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrdersByClientIdQueryKey = (clientId?: number,) => {
    return [
    'orders','client',clientId
    ] as const;
    }

    
export const getGetOrdersByClientIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersByClientId>>, TError = ErrorResponse>(clientId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByClientId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrdersByClientIdQueryKey(clientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersByClientId>>> = ({ signal }) => getOrdersByClientId(clientId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(clientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrdersByClientId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrdersByClientIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersByClientId>>>
export type GetOrdersByClientIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –∫–ª–∏–µ–Ω—Ç–∞
 */

export function useGetOrdersByClientId<TData = Awaited<ReturnType<typeof getOrdersByClientId>>, TError = ErrorResponse>(
 clientId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByClientId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrdersByClientIdQueryOptions(clientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤, –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –Ω–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */
export const getOrdersByManagerId = (
    managerId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO[]>(
      {url: `/orders/manager/${managerId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrdersByManagerIdQueryKey = (managerId?: number,) => {
    return [
    'orders','manager',managerId
    ] as const;
    }

    
export const getGetOrdersByManagerIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersByManagerId>>, TError = ErrorResponse>(managerId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByManagerId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrdersByManagerIdQueryKey(managerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersByManagerId>>> = ({ signal }) => getOrdersByManagerId(managerId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(managerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrdersByManagerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrdersByManagerIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersByManagerId>>>
export type GetOrdersByManagerIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –º–µ–Ω–µ–¥–∂–µ—Ä–∞
 */

export function useGetOrdersByManagerId<TData = Awaited<ReturnType<typeof getOrdersByManagerId>>, TError = ErrorResponse>(
 managerId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByManagerId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrdersByManagerIdQueryOptions(managerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤, –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –Ω–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º —Å—Ç–∞—Ç—É—Å–æ–º
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø–æ —Å—Ç–∞—Ç—É—Å—É
 */
export const getOrdersByManagerIdAndStatus = (
    managerId: number,
    status: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO[]>(
      {url: `/orders/manager/${managerId}/status/${status}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrdersByManagerIdAndStatusQueryKey = (managerId?: number,
    status?: string,) => {
    return [
    'orders','manager',managerId,'status',status
    ] as const;
    }

    
export const getGetOrdersByManagerIdAndStatusQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>, TError = ErrorResponse>(managerId: number,
    status: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrdersByManagerIdAndStatusQueryKey(managerId,status);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>> = ({ signal }) => getOrdersByManagerIdAndStatus(managerId,status, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(managerId && status), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrdersByManagerIdAndStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>>
export type GetOrdersByManagerIdAndStatusQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø–æ —Å—Ç–∞—Ç—É—Å—É
 */

export function useGetOrdersByManagerIdAndStatus<TData = Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>, TError = ErrorResponse>(
 managerId: number,
    status: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByManagerIdAndStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrdersByManagerIdAndStatusQueryOptions(managerId,status,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤ –ø–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º –ø–æ–∏—Å–∫–∞ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
 * @summary –ü–æ–∏—Å–∫ –∑–∞–∫–∞–∑–æ–≤
 */
export const searchOrders = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO[]>(
      {url: `/orders/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchOrdersMutationOptions = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchOrders>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchOrders>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchOrders'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchOrders>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchOrders(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchOrdersMutationResult = NonNullable<Awaited<ReturnType<typeof searchOrders>>>
    export type SearchOrdersMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchOrdersMutationError = ErrorResponse | ValidationErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –∑–∞–∫–∞–∑–æ–≤
 */
export const useSearchOrders = <TError = ErrorResponse | ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchOrders>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchOrdersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º —Å—Ç–∞—Ç—É—Å–æ–º
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ —Å—Ç–∞—Ç—É—Å—É
 */
export const getOrdersByStatus = (
    status: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO[]>(
      {url: `/orders/status/${status}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrdersByStatusQueryKey = (status?: string,) => {
    return [
    'orders','status',status
    ] as const;
    }

    
export const getGetOrdersByStatusQueryOptions = <TData = Awaited<ReturnType<typeof getOrdersByStatus>>, TError = ErrorResponse>(status: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrdersByStatusQueryKey(status);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrdersByStatus>>> = ({ signal }) => getOrdersByStatus(status, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(status), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrdersByStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrdersByStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getOrdersByStatus>>>
export type GetOrdersByStatusQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ —Å—Ç–∞—Ç—É—Å—É
 */

export function useGetOrdersByStatus<TData = Awaited<ReturnType<typeof getOrdersByStatus>>, TError = ErrorResponse>(
 status: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrdersByStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrdersByStatusQueryOptions(status,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–∞–∫–∞–∑ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑ –ø–æ ID
 */
export const getOrderById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO>(
      {url: `/orders/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOrderByIdQueryKey = (id?: number,) => {
    return [
    'orders',id
    ] as const;
    }

    
export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑ –ø–æ ID
 */

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –∑–∞–∫–∞–∑ –ø–æ ID (—Ç–æ–ª—å–∫–æ –¥–ª—è –∑–∞–∫–∞–∑–æ–≤ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–∞—Ö)
 * @summary –£–¥–∞–ª–∏—Ç—å –∑–∞–∫–∞–∑
 */
export const deleteOrder = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/orders/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteOrderMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrder>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteOrder>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOrder>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteOrder(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOrder>>>
    
    export type DeleteOrderMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∑–∞–∫–∞–∑
 */
export const useDeleteOrder = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrder>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –ò–∑–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –∏ –Ω–∞–∑–Ω–∞—á–∞–µ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞ (–µ—Å–ª–∏ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω)
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
 */
export const changeOrderStatus = (
    id: number,
    status: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OrderDTO>(
      {url: `/orders/${id}/status/${status}`, method: 'POST', signal
    },
      options);
    }
  


export const getChangeOrderStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeOrderStatus>>, TError,{id: number;status: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changeOrderStatus>>, TError,{id: number;status: string}, TContext> => {

const mutationKey = ['changeOrderStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeOrderStatus>>, {id: number;status: string}> = (props) => {
          const {id,status} = props ?? {};

          return  changeOrderStatus(id,status,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeOrderStatusMutationResult = NonNullable<Awaited<ReturnType<typeof changeOrderStatus>>>
    
    export type ChangeOrderStatusMutationError = ErrorResponse

    /**
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
 */
export const useChangeOrderStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeOrderStatus>>, TError,{id: number;status: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getChangeOrderStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω
 */
export const getPersonAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO[]>(
      {url: `/persons`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPersonAllQueryKey = () => {
    return [
    'persons'
    ] as const;
    }

    
export const getGetPersonAllQueryOptions = <TData = Awaited<ReturnType<typeof getPersonAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonAll>>> = ({ signal }) => getPersonAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPersonAllQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonAll>>>
export type GetPersonAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–µ—Ä—Å–æ–Ω
 */

export function useGetPersonAll<TData = Awaited<ReturnType<typeof getPersonAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPersonAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –ø–µ—Ä—Å–æ–Ω—É –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const createPerson = (
    createPersonRequest: CreatePersonRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO>(
      {url: `/persons`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPersonRequest, signal
    },
      options);
    }
  


export const getCreatePersonMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerson>>, TError,{data: CreatePersonRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPerson>>, TError,{data: CreatePersonRequest}, TContext> => {

const mutationKey = ['createPerson'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPerson>>, {data: CreatePersonRequest}> = (props) => {
          const {data} = props ?? {};

          return  createPerson(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePersonMutationResult = NonNullable<Awaited<ReturnType<typeof createPerson>>>
    export type CreatePersonMutationBody = CreatePersonRequest
    export type CreatePersonMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const useCreatePerson = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerson>>, TError,{data: CreatePersonRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreatePersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ª—é–¥–µ–π –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –ª—é–¥–µ–π
 */
export const searchPerson = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO[]>(
      {url: `/persons/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  


export const getSearchPersonMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPerson>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchPerson>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext> => {

const mutationKey = ['searchPerson'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchPerson>>, {data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}> = (props) => {
          const {data} = props ?? {};

          return  searchPerson(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchPersonMutationResult = NonNullable<Awaited<ReturnType<typeof searchPerson>>>
    export type SearchPersonMutationBody = GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    export type SearchPersonMutationError = ErrorResponse

    /**
 * @summary –ü–æ–∏—Å–∫ –ª—é–¥–µ–π
 */
export const useSearchPerson = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPerson>>, TError,{data: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getSearchPersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ª–æ–≥–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ –ª–æ–≥–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const getPersonByUserLogin = (
    userLogin: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO>(
      {url: `/persons/user/${userLogin}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPersonByUserLoginQueryKey = (userLogin?: string,) => {
    return [
    'persons','user',userLogin
    ] as const;
    }

    
export const getGetPersonByUserLoginQueryOptions = <TData = Awaited<ReturnType<typeof getPersonByUserLogin>>, TError = ErrorResponse>(userLogin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonByUserLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonByUserLoginQueryKey(userLogin);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonByUserLogin>>> = ({ signal }) => getPersonByUserLogin(userLogin, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userLogin), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonByUserLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPersonByUserLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonByUserLogin>>>
export type GetPersonByUserLoginQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ –ª–æ–≥–∏–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */

export function useGetPersonByUserLogin<TData = Awaited<ReturnType<typeof getPersonByUserLogin>>, TError = ErrorResponse>(
 userLogin: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonByUserLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPersonByUserLoginQueryOptions(userLogin,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ ID
 */
export const getPersonById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonDTO>(
      {url: `/persons/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPersonByIdQueryKey = (id?: number,) => {
    return [
    'persons',id
    ] as const;
    }

    
export const getGetPersonByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPersonById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPersonByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPersonById>>> = ({ signal }) => getPersonById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPersonByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPersonById>>>
export type GetPersonByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É –ø–æ ID
 */

export function useGetPersonById<TData = Awaited<ReturnType<typeof getPersonById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPersonById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPersonByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –ø–µ—Ä—Å–æ–Ω—É –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ (soft delete)
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const deletePerson = (
    id: number,
    params?: DeletePersonParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/persons/${id}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeletePersonMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerson>>, TError,{id: number;params?: DeletePersonParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePerson>>, TError,{id: number;params?: DeletePersonParams}, TContext> => {

const mutationKey = ['deletePerson'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePerson>>, {id: number;params?: DeletePersonParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deletePerson(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePersonMutationResult = NonNullable<Awaited<ReturnType<typeof deletePerson>>>
    
    export type DeletePersonMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø–µ—Ä—Å–æ–Ω—É
 */
export const useDeletePerson = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerson>>, TError,{id: number;params?: DeletePersonParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeletePersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞. –î–ª—è –¥–æ—Å—Ç—É–ø–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è.
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
 */
export const getProductMediaByProductId = (
    productId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductMediaDTO[]>(
      {url: `/product-media/product/${productId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductMediaByProductIdQueryKey = (productId?: number,) => {
    return [
    'product-media','product',productId
    ] as const;
    }

    
export const getGetProductMediaByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductMediaByProductId>>, TError = ErrorResponse>(productId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductMediaByProductId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductMediaByProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductMediaByProductId>>> = ({ signal }) => getProductMediaByProductId(productId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductMediaByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductMediaByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductMediaByProductId>>>
export type GetProductMediaByProductIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞
 */

export function useGetProductMediaByProductId<TData = Awaited<ReturnType<typeof getProductMediaByProductId>>, TError = ErrorResponse>(
 productId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductMediaByProductId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductMediaByProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: JPEG, PNG, GIF. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: 10MB.
 * @summary –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const uploadProductMediaImage = (
    uploadProductMediaImageBody: UploadProductMediaImageBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`product_id`, uploadProductMediaImageBody.product_id.toString())
formData.append(`file`, uploadProductMediaImageBody.file)

      return customInstance<ProductMediaDTO>(
      {url: `/product-media/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getUploadProductMediaImageMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadProductMediaImage>>, TError,{data: UploadProductMediaImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadProductMediaImage>>, TError,{data: UploadProductMediaImageBody}, TContext> => {

const mutationKey = ['uploadProductMediaImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadProductMediaImage>>, {data: UploadProductMediaImageBody}> = (props) => {
          const {data} = props ?? {};

          return  uploadProductMediaImage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadProductMediaImageMutationResult = NonNullable<Awaited<ReturnType<typeof uploadProductMediaImage>>>
    export type UploadProductMediaImageMutationBody = UploadProductMediaImageBody
    export type UploadProductMediaImageMutationError = ErrorResponse

    /**
 * @summary –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const useUploadProductMediaImage = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadProductMediaImage>>, TError,{data: UploadProductMediaImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getUploadProductMediaImageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –£–¥–∞–ª—è–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –ø–æ ID. –£–¥–∞–ª—è–µ—Ç –∫–∞–∫ –∑–∞–ø–∏—Å—å –∏–∑ –ë–î, —Ç–∞–∫ –∏ —Ñ–∞–π–ª —Å –¥–∏—Å–∫–∞.
 * @summary –£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const deleteProductMedia = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/product-media/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProductMediaMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductMedia>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProductMedia>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteProductMedia'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductMedia>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductMedia(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMediaMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductMedia>>>
    
    export type DeleteProductMediaMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
 */
export const useDeleteProductMedia = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductMedia>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteProductMediaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–æ–¥—É–∫—Ç—ã
 */
export const getProductAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO[]>(
      {url: `/products`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductAllQueryKey = () => {
    return [
    'products'
    ] as const;
    }

    
export const getGetProductAllQueryOptions = <TData = Awaited<ReturnType<typeof getProductAll>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductAll>>> = ({ signal }) => getProductAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductAllQueryResult = NonNullable<Awaited<ReturnType<typeof getProductAll>>>
export type GetProductAllQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–æ–¥—É–∫—Ç—ã
 */

export function useGetProductAll<TData = Awaited<ReturnType<typeof getProductAll>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductAll>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –ø—Ä–æ–¥—É–∫—Ç –≤ —Å–∏—Å—Ç–µ–º–µ
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const createProduct = (
    productCreateRequest: ProductCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productCreateRequest, signal
    },
      options);
    }
  


export const getCreateProductMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: ProductCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: ProductCreateRequest}, TContext> => {

const mutationKey = ['createProduct'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProduct>>, {data: ProductCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createProduct(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>
    export type CreateProductMutationBody = ProductCreateRequest
    export type CreateProductMutationError = ErrorResponse

    /**
 * @summary –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const useCreateProduct = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: ProductCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getCreateProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */
export const getProductByCategoryId = (
    categoryId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO[]>(
      {url: `/products/category/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductByCategoryIdQueryKey = (categoryId?: number,) => {
    return [
    'products','category',categoryId
    ] as const;
    }

    
export const getGetProductByCategoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductByCategoryId>>, TError = ErrorResponse>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByCategoryIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductByCategoryId>>> = ({ signal }) => getProductByCategoryId(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductByCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByCategoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductByCategoryId>>>
export type GetProductByCategoryIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
 */

export function useGetProductByCategoryId<TData = Awaited<ReturnType<typeof getProductByCategoryId>>, TError = ErrorResponse>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCategoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByCategoryIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –ò–∑–º–µ–Ω—è–µ—Ç —Ü–µ–Ω—É –ø—Ä–æ–¥—É–∫—Ç–∞ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Ü–µ–Ω—É –ø—Ä–æ–¥—É–∫—Ç–∞
 */
export const changeProductPrice = (
    productPriceChangeRequest: ProductPriceChangeRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products/change-price`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productPriceChangeRequest, signal
    },
      options);
    }
  


export const getChangeProductPriceMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeProductPrice>>, TError,{data: ProductPriceChangeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changeProductPrice>>, TError,{data: ProductPriceChangeRequest}, TContext> => {

const mutationKey = ['changeProductPrice'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeProductPrice>>, {data: ProductPriceChangeRequest}> = (props) => {
          const {data} = props ?? {};

          return  changeProductPrice(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeProductPriceMutationResult = NonNullable<Awaited<ReturnType<typeof changeProductPrice>>>
    export type ChangeProductPriceMutationBody = ProductPriceChangeRequest
    export type ChangeProductPriceMutationError = ErrorResponse

    /**
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Ü–µ–Ω—É –ø—Ä–æ–¥—É–∫—Ç–∞
 */
export const useChangeProductPrice = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeProductPrice>>, TError,{data: ProductPriceChangeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getChangeProductPriceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –ò–∑–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ç—É—Å –ø—Ä–æ–¥—É–∫—Ç–∞ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –∫–æ–¥ —Å—Ç–∞—Ç—É—Å–∞
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø—Ä–æ–¥—É–∫—Ç–∞
 */
export const changeProductStatus = (
    productStatusChangeRequest: ProductStatusChangeRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products/change-status`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productStatusChangeRequest, signal
    },
      options);
    }
  


export const getChangeProductStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeProductStatus>>, TError,{data: ProductStatusChangeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changeProductStatus>>, TError,{data: ProductStatusChangeRequest}, TContext> => {

const mutationKey = ['changeProductStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeProductStatus>>, {data: ProductStatusChangeRequest}> = (props) => {
          const {data} = props ?? {};

          return  changeProductStatus(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeProductStatusMutationResult = NonNullable<Awaited<ReturnType<typeof changeProductStatus>>>
    export type ChangeProductStatusMutationBody = ProductStatusChangeRequest
    export type ChangeProductStatusMutationError = ErrorResponse

    /**
 * @summary –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø—Ä–æ–¥—É–∫—Ç–∞
 */
export const useChangeProductStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeProductStatus>>, TError,{data: ProductStatusChangeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getChangeProductStatusMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∫–æ–¥—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ –∫–æ–¥—É
 */
export const getProductByCode = (
    code: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products/code/${code}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductByCodeQueryKey = (code?: string,) => {
    return [
    'products','code',code
    ] as const;
    }

    
export const getGetProductByCodeQueryOptions = <TData = Awaited<ReturnType<typeof getProductByCode>>, TError = ErrorResponse>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByCodeQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductByCode>>> = ({ signal }) => getProductByCode(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductByCode>>>
export type GetProductByCodeQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ –∫–æ–¥—É
 */

export function useGetProductByCode<TData = Awaited<ReturnType<typeof getProductByCode>>, TError = ErrorResponse>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByCodeQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */
export const searchProduct = (
    githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO[]>(
      {url: `/products/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, signal
    },
      options);
    }
  



export const getSearchProductInfiniteQueryKey = (githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody?: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,) => {
    return [
    'infinite', 'products','search', githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    ] as const;
    }

export const getSearchProductQueryKey = (githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody?: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,) => {
    return [
    'products','search', githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody
    ] as const;
    }

    
export const getSearchProductInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof searchProduct>>>, TError = ErrorResponse>(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProduct>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchProductInfiniteQueryKey(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProduct>>> = ({ signal, pageParam }) => searchProduct({ ...githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, offset: pageParam as number }, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchProductInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchProduct>>>
export type SearchProductInfiniteQueryError = ErrorResponse


/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */

export function useSearchProductInfinite<TData = InfiniteData<Awaited<ReturnType<typeof searchProduct>>>, TError = ErrorResponse>(
 githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProduct>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchProductInfiniteQueryOptions(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSearchProductQueryOptions = <TData = Awaited<ReturnType<typeof searchProduct>>, TError = ErrorResponse>(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProduct>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchProductQueryKey(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProduct>>> = ({ signal }) => searchProduct(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchProductQueryResult = NonNullable<Awaited<ReturnType<typeof searchProduct>>>
export type SearchProductQueryError = ErrorResponse


/**
 * @summary –ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
 */

export function useSearchProduct<TData = Awaited<ReturnType<typeof searchProduct>>, TError = ErrorResponse>(
 githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody: GithubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProduct>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchProductQueryOptions(githubComActuallyHelloBackendstoryPkgCoreSearchCriteriaBody,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID
 */
export const getProductById = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductDTO>(
      {url: `/products/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProductByIdQueryKey = (id?: number,) => {
    return [
    'products',id
    ] as const;
    }

    
export const getGetProductByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductById>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductById>>> = ({ signal }) => getProductById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductById>>>
export type GetProductByIdQueryError = ErrorResponse


/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç –ø–æ ID
 */

export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * –£–¥–∞–ª—è–µ—Ç –ø—Ä–æ–¥—É–∫—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const deleteProduct = (
    id: number,
    params?: DeleteProductParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/products/${id}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteProductMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{id: number;params?: DeleteProductParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{id: number;params?: DeleteProductParams}, TContext> => {

const mutationKey = ['deleteProduct'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProduct>>, {id: number;params?: DeleteProductParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deleteProduct(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>
    
    export type DeleteProductMutationError = ErrorResponse

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç
 */
export const useDeleteProduct = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{id: number;params?: DeleteProductParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getDeleteProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–∫–µ–Ω
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const registerUser = (
    registerUserRequest: RegisterUserRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerUserRequest, signal
    },
      options);
    }
  


export const getRegisterUserMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegisterUserRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegisterUserRequest}, TContext> => {

const mutationKey = ['registerUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUser>>, {data: RegisterUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUserMutationResult = NonNullable<Awaited<ReturnType<typeof registerUser>>>
    export type RegisterUserMutationBody = RegisterUserRequest
    export type RegisterUserMutationError = ErrorResponse

    /**
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const useRegisterUser = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegisterUserRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient) => {

      const mutationOptions = getRegisterUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
